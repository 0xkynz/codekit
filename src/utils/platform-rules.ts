/**
 * Multi-platform AI assistant rule generation
 * Supports: Claude Code, Cursor, Gemini CLI
 */

import { ProjectContext, PackageDependencies } from "./project-scanner";

export type AIPlatform = "claude" | "cursor" | "gemini";

export interface PlatformConfig {
  name: string;
  displayName: string;
  files: string[];
  description: string;
}

export const PLATFORMS: Record<AIPlatform, PlatformConfig> = {
  claude: {
    name: "claude",
    displayName: "Claude Code",
    files: ["CLAUDE.md"],
    description: "Anthropic Claude Code CLI",
  },
  cursor: {
    name: "cursor",
    displayName: "Cursor",
    files: [".cursorrules"],
    description: "Cursor AI IDE",
  },
  gemini: {
    name: "gemini",
    displayName: "Gemini CLI",
    files: ["GEMINI.md"],
    description: "Google Gemini CLI (Antigravity)",
  },
};

export const ALL_PLATFORMS: AIPlatform[] = ["claude", "cursor", "gemini"];

/**
 * Generate rules for all supported platforms
 */
export function generateAllPlatformRules(context: ProjectContext): Record<AIPlatform, string> {
  return {
    claude: generateClaudeRules(context),
    cursor: generateCursorRules(context),
    gemini: generateGeminiRules(context),
  };
}

/**
 * Generate Claude Code rules (CLAUDE.md)
 */
export function generateClaudeRules(context: ProjectContext): string {
  const sections: string[] = [];

  // Header with critical memory-bank instruction
  sections.push(`# ${context.name} - Project Rules for Claude

> **IMPORTANT: Always read the \`memory-bank/\` directory at the start of each session.**
> This contains essential project context, current progress, and active decisions.

This file contains project-specific rules and context for Claude Code.
`);

  // Tech Stack
  sections.push(generateTechStackSection(context));

  // Dependencies
  const depsSection = generateDependenciesSection(context.dependencies);
  if (depsSection) {
    sections.push(depsSection);
  }

  // Project Structure
  sections.push(generateStructureSection(context));

  // Code Style
  sections.push(generateCodeStyleSection(context));

  // Architecture
  if (context.patterns.architecture.length > 0) {
    sections.push(generateArchitectureSection(context));
  }

  // Testing
  if (context.patterns.testing.length > 0) {
    sections.push(generateTestingSection(context));
  }

  // Development Workflow
  sections.push(generateWorkflowSection(context));

  // Important Notes
  sections.push(`## Important Notes

### Memory Bank (Critical)
**You MUST read the \`memory-bank/\` directory at the start of EVERY session.** The memory bank contains:
- \`projectbrief.md\` - Core requirements and goals
- \`productContext.md\` - Problem and solution context
- \`techContext.md\` - Technical setup and dependencies
- \`systemPatterns.md\` - Architecture and design patterns
- \`activeContext.md\` - Current work focus and recent changes
- \`progress.md\` - Completed work and known issues

### Workflow
1. **Start of session:** Read all memory-bank files
2. **Before coding:** Check activeContext.md for current focus
3. **After changes:** Update activeContext.md and progress.md
4. **Follow patterns:** Match existing code style and architecture
5. **Test first:** Run tests before committing changes
`);

  return sections.join("\n");
}

/**
 * Generate Cursor rules (.cursorrules)
 */
export function generateCursorRules(context: ProjectContext): string {
  const sections: string[] = [];

  // Header comment with memory-bank instruction
  sections.push(`# Cursor Rules for ${context.name}
# This file configures Cursor AI assistant behavior for this project.
# Generated by codekit

# IMPORTANT: Read the memory-bank/ directory at the start of each session.
# It contains project context, current progress, and active decisions.
`);

  // Project Overview
  sections.push(`## Project Overview

This is a ${context.techStack.frameworks.join("/") || context.techStack.languages.join("/")} project.
`);

  // Tech Stack (compact format for Cursor)
  sections.push(`## Tech Stack
${context.techStack.languages.length > 0 ? `- Languages: ${context.techStack.languages.join(", ")}` : ""}
${context.techStack.frameworks.length > 0 ? `- Frameworks: ${context.techStack.frameworks.join(", ")}` : ""}
${context.techStack.buildTools.length > 0 ? `- Build: ${context.techStack.buildTools.join(", ")}` : ""}
${context.techStack.testingTools.length > 0 ? `- Testing: ${context.techStack.testingTools.join(", ")}` : ""}
${context.techStack.packageManager ? `- Package Manager: ${context.techStack.packageManager}` : ""}
${context.techStack.runtime ? `- Runtime: ${context.techStack.runtime}` : ""}
`);

  // Dependencies summary
  const depsSummary = generateDependenciesSummary(context.dependencies);
  if (depsSummary) {
    sections.push(`## Dependencies
${depsSummary}
`);
  }

  // Code Style
  const style = context.patterns.codeStyle;
  sections.push(`## Code Style Guidelines
${style.usesTypeScript ? "- Use TypeScript for all new code" : "- JavaScript project"}
${style.usesSemicolons !== null ? (style.usesSemicolons ? "- Use semicolons at end of statements" : "- Do not use semicolons") : ""}
${style.quoteStyle ? `- Use ${style.quoteStyle} quotes for strings` : ""}
${style.usesTabIndent !== null ? (style.usesTabIndent ? "- Use tabs for indentation" : "- Use spaces for indentation") : ""}
${style.hasLinter ? "- Follow ESLint rules defined in project" : ""}
${style.hasFormatter ? "- Code is auto-formatted with Prettier" : ""}
`);

  // Project Structure
  sections.push(`## Project Structure
${context.structure.srcDir ? `- Source: \`${context.structure.srcDir}/\`` : ""}
${context.structure.testDir ? `- Tests: \`${context.structure.testDir}/\`` : ""}
${context.structure.entryPoints.length > 0 ? `- Entry: ${context.structure.entryPoints.map(e => `\`${e}\``).join(", ")}` : ""}
`);

  // Architecture patterns
  if (context.patterns.architecture.length > 0) {
    sections.push(`## Architecture
${context.patterns.architecture.map(p => `- ${p}`).join("\n")}
`);
  }

  // Instructions with memory-bank workflow
  sections.push(`## Instructions

### Memory Bank (Read First!)
At the start of each session, read the \`memory-bank/\` directory:
- \`activeContext.md\` - Current work focus
- \`progress.md\` - Completed work and issues
- \`systemPatterns.md\` - Architecture patterns
- \`techContext.md\` - Technical setup

### Workflow
1. **Start:** Read memory-bank files first
2. **Code:** Follow existing patterns and style
3. **Test:** Run \`${context.techStack.packageManager || "npm"} run test\` before completing
4. **Update:** Update activeContext.md and progress.md after changes

### Code Guidelines
1. Follow the existing code patterns and style in this project
2. Write clean, maintainable code with appropriate comments
3. Include tests for new functionality
4. Use the project's established patterns for state management, API calls, etc.
`);

  return sections.join("\n");
}

/**
 * Generate Gemini CLI rules (GEMINI.md)
 */
export function generateGeminiRules(context: ProjectContext): string {
  const sections: string[] = [];

  // Header with critical memory-bank instruction
  sections.push(`# ${context.name} - Gemini CLI Project Context

> **IMPORTANT: Always read the \`memory-bank/\` directory at the start of each session.**
> This contains essential project context, current progress, and active decisions.

This file provides project context and rules for Google Gemini CLI.
`);

  // Project Summary
  sections.push(`## Project Summary

**Name:** ${context.name}
**Type:** ${context.techStack.frameworks.join(", ") || context.techStack.languages.join(", ")} application
${context.techStack.packageManager ? `**Package Manager:** ${context.techStack.packageManager}` : ""}
${context.techStack.runtime ? `**Runtime:** ${context.techStack.runtime}` : ""}
`);

  // Technology Stack
  sections.push(`## Technology Stack

### Languages
${context.techStack.languages.map(l => `- ${l}`).join("\n") || "- Not detected"}

### Frameworks
${context.techStack.frameworks.map(f => `- ${f}`).join("\n") || "- None"}

### Build Tools
${context.techStack.buildTools.map(b => `- ${b}`).join("\n") || "- None"}

### Testing
${context.techStack.testingTools.map(t => `- ${t}`).join("\n") || "- Not configured"}
`);

  // Dependencies
  const depsSummary = generateDependenciesSummary(context.dependencies);
  if (depsSummary) {
    sections.push(`## Dependencies

${depsSummary}
`);
  }

  // Project Structure
  sections.push(`## Project Structure

\`\`\`
${context.name}/
${context.structure.srcDir ? `├── ${context.structure.srcDir}/          # Source code` : ""}
${context.structure.testDir ? `├── ${context.structure.testDir}/         # Tests` : ""}
${context.structure.docsDir ? `├── ${context.structure.docsDir}/         # Documentation` : ""}
${context.configFiles.slice(0, 8).map(f => `├── ${f}`).join("\n")}
\`\`\`
`);

  // Code Conventions
  const style = context.patterns.codeStyle;
  sections.push(`## Code Conventions

- **TypeScript:** ${style.usesTypeScript ? "Yes - use TypeScript for all new code" : "No - JavaScript project"}
${style.usesSemicolons !== null ? `- **Semicolons:** ${style.usesSemicolons ? "Required" : "Not used"}` : ""}
${style.quoteStyle ? `- **Quotes:** ${style.quoteStyle === "single" ? "Single quotes" : "Double quotes"}` : ""}
${style.usesTabIndent !== null ? `- **Indentation:** ${style.usesTabIndent ? "Tabs" : "Spaces"}` : ""}
- **Linter:** ${style.hasLinter ? "ESLint configured" : "Not configured"}
- **Formatter:** ${style.hasFormatter ? "Prettier configured" : "Not configured"}
`);

  // Architecture
  if (context.patterns.architecture.length > 0) {
    sections.push(`## Architecture Patterns

${context.patterns.architecture.map(p => `- ${p}`).join("\n")}
`);
  }

  // Development Commands
  sections.push(`## Development Commands

\`\`\`bash
# Install dependencies
${context.techStack.packageManager || "npm"} install

# Start development server
${context.techStack.packageManager || "npm"} run dev

# Run tests
${context.techStack.packageManager || "npm"} run test

# Build for production
${context.techStack.packageManager || "npm"} run build
\`\`\`
`);

  // Guidelines with memory-bank workflow
  sections.push(`## Guidelines for Gemini

### Memory Bank (Critical)
**You MUST read the \`memory-bank/\` directory at the start of EVERY session.** The memory bank contains:
- \`projectbrief.md\` - Core requirements and goals
- \`productContext.md\` - Problem and solution context
- \`techContext.md\` - Technical setup and dependencies
- \`systemPatterns.md\` - Architecture and design patterns
- \`activeContext.md\` - Current work focus and recent changes
- \`progress.md\` - Completed work and known issues

### Workflow
1. **Start of session:** Read all memory-bank files first
2. **Before coding:** Check activeContext.md for current focus
3. **After changes:** Update activeContext.md and progress.md

### Code Guidelines
1. **Follow existing patterns** - Match the code style and architecture already in use
2. **Type safety** - ${style.usesTypeScript ? "Ensure proper TypeScript types" : "Add JSDoc comments for documentation"}
3. **Testing** - Write tests for new functionality using ${context.techStack.testingTools.join(", ") || "the project's test framework"}
4. **Code quality** - ${style.hasLinter ? "Ensure code passes ESLint" : "Write clean, readable code"}
5. **Dependencies** - Prefer using existing dependencies over adding new ones
`);

  return sections.join("\n");
}

// ============================================================================
// Helper functions for generating sections
// ============================================================================

function generateTechStackSection(context: ProjectContext): string {
  const lines: string[] = [`## Tech Stack\n`];

  if (context.techStack.languages.length > 0) {
    lines.push(`**Languages:** ${context.techStack.languages.join(", ")}`);
  }
  if (context.techStack.frameworks.length > 0) {
    lines.push(`**Frameworks:** ${context.techStack.frameworks.join(", ")}`);
  }
  if (context.techStack.buildTools.length > 0) {
    lines.push(`**Build Tools:** ${context.techStack.buildTools.join(", ")}`);
  }
  if (context.techStack.testingTools.length > 0) {
    lines.push(`**Testing:** ${context.techStack.testingTools.join(", ")}`);
  }
  if (context.techStack.packageManager) {
    lines.push(`**Package Manager:** ${context.techStack.packageManager}`);
  }
  if (context.techStack.runtime) {
    lines.push(`**Runtime:** ${context.techStack.runtime}`);
  }
  lines.push("");

  return lines.join("\n");
}

function generateStructureSection(context: ProjectContext): string {
  const lines: string[] = [`## Project Structure\n`];

  if (context.structure.srcDir) {
    lines.push(`- Source code: \`${context.structure.srcDir}/\``);
  }
  if (context.structure.testDir) {
    lines.push(`- Tests: \`${context.structure.testDir}/\``);
  }
  if (context.structure.docsDir) {
    lines.push(`- Documentation: \`${context.structure.docsDir}/\``);
  }
  if (context.structure.entryPoints.length > 0) {
    lines.push(`- Entry points: ${context.structure.entryPoints.map(e => `\`${e}\``).join(", ")}`);
  }
  if (context.structure.hasMonorepo) {
    lines.push(`- **Monorepo structure detected**`);
  }
  lines.push("");

  return lines.join("\n");
}

function generateCodeStyleSection(context: ProjectContext): string {
  const lines: string[] = [`## Code Style\n`];
  const style = context.patterns.codeStyle;

  if (style.usesTypeScript) {
    lines.push(`- Use TypeScript for all new code`);
  }
  if (style.usesSemicolons !== null) {
    lines.push(`- ${style.usesSemicolons ? "Use semicolons" : "No semicolons (omit them)"}`);
  }
  if (style.quoteStyle) {
    lines.push(`- Use ${style.quoteStyle} quotes for strings`);
  }
  if (style.usesTabIndent !== null) {
    lines.push(`- ${style.usesTabIndent ? "Use tabs for indentation" : "Use spaces for indentation"}`);
  }
  if (style.hasLinter) {
    lines.push(`- ESLint is configured - follow existing lint rules`);
  }
  if (style.hasFormatter) {
    lines.push(`- Prettier is configured - code will be auto-formatted`);
  }
  lines.push("");

  return lines.join("\n");
}

function generateArchitectureSection(context: ProjectContext): string {
  const lines: string[] = [`## Architecture Patterns\n`];
  for (const pattern of context.patterns.architecture) {
    lines.push(`- ${pattern}`);
  }
  lines.push("");
  return lines.join("\n");
}

function generateTestingSection(context: ProjectContext): string {
  const lines: string[] = [`## Testing\n`];
  for (const pattern of context.patterns.testing) {
    lines.push(`- ${pattern}`);
  }
  lines.push("");
  return lines.join("\n");
}

function generateWorkflowSection(context: ProjectContext): string {
  const lines: string[] = [`## Development Workflow\n`];

  if (context.techStack.packageManager) {
    lines.push(`\`\`\`bash
# Install dependencies
${context.techStack.packageManager} install

# Run development server
${context.techStack.packageManager} run dev

# Run tests
${context.techStack.packageManager} run test

# Build for production
${context.techStack.packageManager} run build
\`\`\`
`);
  }

  return lines.join("\n");
}

/**
 * Generate dependencies section with tables (for CLAUDE.md)
 */
function generateDependenciesSection(deps: PackageDependencies): string | null {
  const sections: string[] = [];
  let hasAnyDeps = false;

  // JavaScript/TypeScript
  if (deps.javascript) {
    hasAnyDeps = true;
    sections.push(`## Dependencies (JavaScript/TypeScript)

**Source:** \`package.json\`
`);

    const prodDeps = Object.entries(deps.javascript.dependencies);
    if (prodDeps.length > 0) {
      sections.push(`### Production Dependencies
| Package | Version |
|---------|---------|
${prodDeps.map(([name, version]) => `| ${name} | ${version} |`).join("\n")}
`);
    }

    const devDeps = Object.entries(deps.javascript.devDependencies);
    if (devDeps.length > 0) {
      sections.push(`### Dev Dependencies
| Package | Version |
|---------|---------|
${devDeps.map(([name, version]) => `| ${name} | ${version} |`).join("\n")}
`);
    }

    if (deps.javascript.scripts && Object.keys(deps.javascript.scripts).length > 0) {
      sections.push(`### Available Scripts
| Script | Command |
|--------|---------|
${Object.entries(deps.javascript.scripts).map(([name, cmd]) => `| ${name} | \`${cmd}\` |`).join("\n")}
`);
    }
  }

  // Python
  if (deps.python) {
    hasAnyDeps = true;
    sections.push(`## Dependencies (Python)

**Source:** \`${deps.python.source}\`

### Dependencies
| Package | Version |
|---------|---------|
${deps.python.dependencies.map(d => `| ${d.name}${d.extras ? `[${d.extras.join(",")}]` : ""} | ${d.version || "*"} |`).join("\n")}
`);
  }

  // Rust
  if (deps.rust) {
    hasAnyDeps = true;
    sections.push(`## Dependencies (Rust)

**Source:** \`Cargo.toml\`

### Dependencies
| Crate | Version |
|-------|---------|
${Object.entries(deps.rust.dependencies).map(([name, ver]) => {
  const version = typeof ver === "string" ? ver : ver.version;
  return `| ${name} | ${version} |`;
}).join("\n")}
`);
  }

  // Go
  if (deps.go) {
    hasAnyDeps = true;
    sections.push(`## Dependencies (Go)

**Source:** \`go.mod\`
**Module:** \`${deps.go.module}\`
${deps.go.goVersion ? `**Go Version:** ${deps.go.goVersion}` : ""}

### Dependencies
| Module | Version |
|--------|---------|
${deps.go.dependencies.map(d => `| ${d.path} | ${d.version} |`).join("\n")}
`);
  }

  // Add other languages as needed...

  if (!hasAnyDeps) return null;
  return sections.join("\n");
}

/**
 * Generate a compact dependencies summary (for Cursor/Gemini)
 */
function generateDependenciesSummary(deps: PackageDependencies): string | null {
  const lines: string[] = [];

  if (deps.javascript) {
    const prodDeps = Object.keys(deps.javascript.dependencies);
    const devDeps = Object.keys(deps.javascript.devDependencies);
    lines.push(`**JavaScript (package.json):**`);
    lines.push(`- Production (${prodDeps.length}): ${prodDeps.slice(0, 15).join(", ")}${prodDeps.length > 15 ? ` +${prodDeps.length - 15} more` : ""}`);
    lines.push(`- Dev (${devDeps.length}): ${devDeps.slice(0, 10).join(", ")}${devDeps.length > 10 ? ` +${devDeps.length - 10} more` : ""}`);
  }

  if (deps.python) {
    const pkgs = deps.python.dependencies.map(d => d.name);
    lines.push(`**Python (${deps.python.source}):**`);
    lines.push(`- Packages (${pkgs.length}): ${pkgs.slice(0, 15).join(", ")}${pkgs.length > 15 ? ` +${pkgs.length - 15} more` : ""}`);
  }

  if (deps.rust) {
    const crates = Object.keys(deps.rust.dependencies);
    lines.push(`**Rust (Cargo.toml):**`);
    lines.push(`- Crates (${crates.length}): ${crates.slice(0, 15).join(", ")}${crates.length > 15 ? ` +${crates.length - 15} more` : ""}`);
  }

  if (deps.go) {
    const mods = deps.go.dependencies.map(d => d.path.split("/").pop() || d.path);
    lines.push(`**Go (go.mod):**`);
    lines.push(`- Module: ${deps.go.module}`);
    lines.push(`- Dependencies (${mods.length}): ${mods.slice(0, 10).join(", ")}${mods.length > 10 ? ` +${mods.length - 10} more` : ""}`);
  }

  if (deps.ruby) {
    const gems = deps.ruby.dependencies.map(d => d.name);
    lines.push(`**Ruby (Gemfile):**`);
    lines.push(`- Gems (${gems.length}): ${gems.slice(0, 15).join(", ")}${gems.length > 15 ? ` +${gems.length - 15} more` : ""}`);
  }

  if (deps.java) {
    const artifacts = deps.java.dependencies.map(d => d.artifactId);
    lines.push(`**Java (${deps.java.source}):**`);
    lines.push(`- Artifacts (${artifacts.length}): ${artifacts.slice(0, 10).join(", ")}${artifacts.length > 10 ? ` +${artifacts.length - 10} more` : ""}`);
  }

  if (deps.php) {
    const pkgs = Object.keys(deps.php.dependencies);
    lines.push(`**PHP (composer.json):**`);
    lines.push(`- Packages (${pkgs.length}): ${pkgs.slice(0, 15).join(", ")}${pkgs.length > 15 ? ` +${pkgs.length - 15} more` : ""}`);
  }

  if (deps.dotnet) {
    const pkgs = deps.dotnet.dependencies.map(d => d.name);
    lines.push(`**.NET (${deps.dotnet.targetFramework || "csproj"}):**`);
    lines.push(`- Packages (${pkgs.length}): ${pkgs.slice(0, 15).join(", ")}${pkgs.length > 15 ? ` +${pkgs.length - 15} more` : ""}`);
  }

  if (lines.length === 0) return null;
  return lines.join("\n");
}

/**
 * Get the output file path for a platform
 */
export function getPlatformFilePath(platform: AIPlatform, rootDir: string): string {
  const { join } = require("path");
  switch (platform) {
    case "claude":
      return join(rootDir, "CLAUDE.md");
    case "cursor":
      return join(rootDir, ".cursorrules");
    case "gemini":
      return join(rootDir, "GEMINI.md");
    default:
      throw new Error(`Unknown platform: ${platform}`);
  }
}
