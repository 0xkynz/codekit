#!/usr/bin/env bun
/**
 * Generate Virtual File System for bundled templates
 * This script embeds all templates as strings for the compiled binary
 */

import { readdir, readFile, writeFile } from "fs/promises";
import { join, relative } from "path";

const TEMPLATES_DIR = join(import.meta.dir, "../templates");
const OUTPUT_FILE = join(import.meta.dir, "../src/templates.generated.ts");

interface TemplateEntry {
  path: string;
  content: string;
}

async function scanDirectory(dir: string, basePath: string = ""): Promise<TemplateEntry[]> {
  const entries: TemplateEntry[] = [];

  try {
    const items = await readdir(dir, { withFileTypes: true });

    for (const item of items) {
      const fullPath = join(dir, item.name);
      const relativePath = basePath ? `${basePath}/${item.name}` : item.name;

      if (item.isDirectory()) {
        const subEntries = await scanDirectory(fullPath, relativePath);
        entries.push(...subEntries);
      } else {
        const content = await readFile(fullPath, "utf-8");
        entries.push({
          path: relativePath,
          content,
        });
      }
    }
  } catch (error) {
    console.error(`Error scanning ${dir}:`, error);
  }

  return entries;
}

async function generateVFS(): Promise<void> {
  console.log("Scanning templates directory...");

  const resourceTypes = ["agents", "commands", "skills"];
  const allEntries: Map<string, string> = new Map();
  const manifests: Map<string, unknown> = new Map();

  for (const resourceType of resourceTypes) {
    const dir = join(TEMPLATES_DIR, resourceType);
    const entries = await scanDirectory(dir, resourceType);

    for (const entry of entries) {
      allEntries.set(entry.path, entry.content);

      // Extract manifest
      if (entry.path === `${resourceType}/index.json`) {
        try {
          manifests.set(resourceType, JSON.parse(entry.content));
        } catch (e) {
          console.warn(`Failed to parse manifest for ${resourceType}`);
        }
      }
    }
  }

  console.log(`Found ${allEntries.size} template files`);

  // Generate TypeScript output
  const output = `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by scripts/generate-vfs.ts at ${new Date().toISOString()}

const templates: Record<string, string> = ${JSON.stringify(Object.fromEntries(allEntries), null, 2)};

const manifests: Record<string, unknown> = ${JSON.stringify(Object.fromEntries(manifests), null, 2)};

export function get(path: string): string {
  if (!(path in templates)) {
    throw new Error(\`Template not found: \${path}\`);
  }
  return templates[path];
}

export function has(path: string): boolean {
  return path in templates;
}

export function list(): string[] {
  return Object.keys(templates);
}

export function getManifest(resourceType: string): unknown {
  return manifests[resourceType] || { version: "1.0.0", resources: [] };
}

export { manifests };
`;

  await writeFile(OUTPUT_FILE, output, "utf-8");
  console.log(`Generated ${OUTPUT_FILE}`);
}

// Run
generateVFS().catch(console.error);
